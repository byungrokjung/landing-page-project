# AI 트렌드 수집 시스템 아키텍처

## 📋 현재 vs 개선된 구조

### 현재 구조 (동기식)
```
프론트엔드 → n8n 웹훅 → 즉시 처리 → 즉시 응답
```

### 개선된 구조 (비동기식)
```
프론트엔드 → n8n 웹훅 → 즉시 응답(job_id) → 백그라운드 처리
     ↓
폴링/웹소켓 → 상태 확인 → 완료 시 결과 가져오기
```

## 🔧 구현 방법들

### 방법 1: 폴링 방식 (가장 간단)
1. **n8n에서 즉시 응답**: `{job_id: "12345", status: "processing"}`
2. **프론트엔드에서 주기적 확인**: 5초마다 상태 체크
3. **완료 시 데이터 가져오기**: status가 "completed"가 되면 결과 로드

### 방법 2: 웹소켓 방식 (실시간)
1. **n8n에서 백엔드로 완료 알림**
2. **백엔드에서 프론트엔드로 실시간 푸시**
3. **즉시 UI 업데이트**

### 방법 3: 서버센트 이벤트 (SSE)
1. **프론트엔드에서 SSE 연결 유지**
2. **n8n 완료 시 백엔드를 통해 이벤트 전송**
3. **실시간으로 데이터 업데이트**

## 💾 데이터 저장 위치

### 옵션 1: Supabase 데이터베이스
- **장점**: 기존 DB 활용, 영구 저장, 히스토리 관리
- **테이블**: `ai_trends_jobs`, `ai_trends_data`

### 옵션 2: n8n 내부 저장
- **장점**: 별도 DB 불필요
- **단점**: n8n 재시작 시 데이터 손실 가능

### 옵션 3: Redis/메모리 캐시
- **장점**: 빠른 접근, 임시 데이터에 적합
- **단점**: 서버 재시작 시 데이터 손실

## 🎯 추천 구현 순서

1. **폴링 방식으로 시작** (가장 간단)
2. **Supabase에 job 상태 저장**
3. **필요시 웹소켓으로 업그레이드**